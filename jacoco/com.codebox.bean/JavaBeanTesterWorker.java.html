<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaBeanTesterWorker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">javabean-tester</a> &gt; <a href="index.source.html" class="el_package">com.codebox.bean</a> &gt; <span class="el_source">JavaBeanTesterWorker.java</span></div><h1>JavaBeanTesterWorker.java</h1><pre class="source lang-java linenums">/*
 * SPDX-License-Identifier: Apache-2.0
 * See LICENSE file for details.
 *
 * Copyright 2012-2026 hazendaz
 *
 * Portions of initial baseline code (getter/setter test) by Rob Dawson (CodeBox)
 */
package com.codebox.bean;

import com.codebox.enums.CheckClear;
import com.codebox.enums.CheckConstructor;
import com.codebox.enums.CheckEquals;
import com.codebox.enums.CheckSerialize;
import com.codebox.enums.LoadData;
import com.codebox.enums.LoadType;
import com.codebox.enums.SkipStrictSerialize;
import com.codebox.instance.ClassInstance;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import lombok.Data;

import nl.jqno.equalsverifier.EqualsVerifier;
import nl.jqno.equalsverifier.Warning;

import org.junit.jupiter.api.Assertions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Class JavaBeanTesterWorker.
 *
 * @param &lt;T&gt;
 *            the generic type
 * @param &lt;E&gt;
 *            the element type
 */
@Data
class JavaBeanTesterWorker&lt;T, E&gt; {

    /** The Constant logger. */
<span class="fc" id="L63">    private static final Logger logger = LoggerFactory.getLogger(JavaBeanTesterWorker.class);</span>

    /** The check clear. */
    private CheckClear checkClear;

    /** The check constructor. */
    private CheckConstructor checkConstructor;

    /** The check equals. */
    private CheckEquals checkEquals;

    /** The check serializable. */
    private CheckSerialize checkSerializable;

    /** The load data. */
    private LoadData loadData;

    /** The clazz. */
    private final Class&lt;T&gt; clazz;

    /** The extension. */
    private Class&lt;E&gt; extension;

    /** The skip strict serialize. */
    private SkipStrictSerialize skipStrictSerializable;

    /** The skip these. */
<span class="fc" id="L90">    private Set&lt;String&gt; skipThese = new HashSet&lt;&gt;();</span>

    /**
     * Instantiates a new java bean tester worker.
     *
     * @param newClazz
     *            the clazz
     */
<span class="fc" id="L98">    JavaBeanTesterWorker(final Class&lt;T&gt; newClazz) {</span>
<span class="fc" id="L99">        this.clazz = newClazz;</span>
<span class="fc" id="L100">    }</span>

    /**
     * Instantiates a new java bean tester worker.
     *
     * @param newClazz
     *            the clazz
     * @param newExtension
     *            the extension
     */
<span class="fc" id="L110">    JavaBeanTesterWorker(final Class&lt;T&gt; newClazz, final Class&lt;E&gt; newExtension) {</span>
<span class="fc" id="L111">        this.clazz = newClazz;</span>
<span class="fc" id="L112">        this.extension = newExtension;</span>
<span class="fc" id="L113">    }</span>

    /**
     * Tests the load methods of the specified class.
     *
     * @param &lt;L&gt;
     *            the type parameter associated with the class under test.
     * @param clazz
     *            the class under test.
     * @param instance
     *            the instance of class under test.
     * @param loadData
     *            load recursively all underlying data objects.
     * @param skipThese
     *            the names of any properties that should not be tested.
     *
     * @return the java bean tester worker
     */
    public static &lt;L&gt; JavaBeanTesterWorker&lt;L, Object&gt; load(final Class&lt;L&gt; clazz, final L instance,
            final LoadData loadData, final String... skipThese) {
<span class="fc" id="L133">        final JavaBeanTesterWorker&lt;L, Object&gt; worker = new JavaBeanTesterWorker&lt;&gt;(clazz);</span>

<span class="fc" id="L135">        worker.setLoadData(loadData);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if (skipThese != null) {</span>
<span class="fc" id="L137">            worker.setSkipThese(new HashSet&lt;&gt;(Arrays.asList(skipThese)));</span>
        }
<span class="fc" id="L139">        worker.getterSetterTests(instance);</span>

<span class="fc" id="L141">        return worker;</span>
    }

    /**
     * Tests the clear, get, set, equals, hashCode, toString, serializable, and constructor(s) methods of the specified
     * class.
     */
    public void test() {

        // Test Getter/Setter
<span class="fc" id="L151">        this.getterSetterTests(new ClassInstance&lt;T&gt;().newInstance(this.clazz));</span>

        // Test Clear
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (this.checkClear != CheckClear.OFF) {</span>
<span class="fc" id="L155">            this.clearTest();</span>
        }

        // Test constructor
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (this.checkConstructor != CheckConstructor.OFF) {</span>
<span class="fc" id="L160">            this.constructorsTest();</span>
        }

        // Test Serializable (internally uses on/off/strict checks)
<span class="fc" id="L164">        this.checkSerializableTest();</span>

        // Test Equals
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (this.checkEquals == CheckEquals.ON) {</span>
<span class="fc" id="L168">            this.equalsHashCodeToStringSymmetricTest();</span>
        }

<span class="fc" id="L171">    }</span>

    /**
     * Getter Setter Tests.
     *
     * @param instance
     *            the instance of class under test.
     */
    void getterSetterTests(final T instance) {
<span class="fc" id="L180">        final PropertyDescriptor[] props = this.getProps(this.clazz);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (final PropertyDescriptor prop : props) {</span>
<span class="fc" id="L182">            Method getter = prop.getReadMethod();</span>
<span class="fc" id="L183">            final Method setter = prop.getWriteMethod();</span>

            // Java Metro Bug Patch (Boolean Wrapper usage of 'is' possible
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">            if (getter == null &amp;&amp; setter != null) {</span>
<span class="fc" id="L187">                final String isBooleanWrapper = &quot;is&quot; + setter.getName().substring(3);</span>
                try {
<span class="fc" id="L189">                    getter = this.clazz.getMethod(isBooleanWrapper);</span>
<span class="fc" id="L190">                } catch (NoSuchMethodException | SecurityException e) {</span>
                    // Do nothing
<span class="fc" id="L192">                }</span>
            }

<span class="fc bfc" id="L195" title="All 4 branches covered.">            if (getter != null &amp;&amp; setter != null) {</span>
                // We have both a get and set method for this property
<span class="fc" id="L197">                final Class&lt;?&gt; returnType = getter.getReturnType();</span>
<span class="fc" id="L198">                final Class&lt;?&gt;[] params = setter.getParameterTypes();</span>

<span class="pc bpc" id="L200" title="2 of 4 branches missed.">                if (params.length == 1 &amp;&amp; params[0] == returnType) {</span>
                    // The set method has 1 argument, which is of the same type as the return type of the get method, so
                    // we can test this property
                    try {
                        // Build a value of the correct type to be passed to the set method
<span class="fc" id="L205">                        final Object value = this.buildValue(returnType, LoadType.STANDARD_DATA);</span>

                        // Build an instance of the bean that we are testing (each property test gets a new instance)
<span class="fc" id="L208">                        final T bean = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L211">                        setter.invoke(bean, value);</span>

                        // Use data set on instance
<span class="fc" id="L214">                        setter.invoke(instance, value);</span>

<span class="fc" id="L216">                        final Object expectedValue = value;</span>
<span class="fc" id="L217">                        Object actualValue = getter.invoke(bean);</span>

                        // java.util.Date normalization patch
                        //
                        // Date is zero based so it adds 1 through normalization. Since we always pass '1' here, it is
                        // the same as stating February. Thus we roll over the month quite often into March towards
                        // end of the month resulting in '1' != '2' situation. The reason we pass '1' is that we are
                        // testing the content of the object and have no idea it is a date to start with. It is simply
                        // that it sees getters/setters and tries to load them appropriately. The underlying problem
                        // with that is that the Date object performs normalization to avoid dates like 2-30 that do
                        // not exist and is not a typical getter/setter use-case. It is also deprecated but we don't
                        // want to simply skip all deprecated items as we intend to test as much as possible.
                        //
<span class="fc bfc" id="L230" title="All 4 branches covered.">                        if (this.clazz == Date.class &amp;&amp; prop.getName().equals(&quot;month&quot;)</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                                &amp;&amp; expectedValue.equals(Integer.valueOf(&quot;1&quot;))</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                                &amp;&amp; actualValue.equals(Integer.valueOf(&quot;2&quot;))) {</span>
<span class="nc" id="L233">                            actualValue = Integer.valueOf(&quot;1&quot;);</span>
                        }

<span class="fc" id="L236">                        Assertions.assertEquals(expectedValue, actualValue,</span>
<span class="fc" id="L237">                                String.format(&quot;Failed while testing property '%s' of class '%s'&quot;, prop.getName(),</span>
<span class="fc" id="L238">                                        this.clazz.getName()));</span>

<span class="nc" id="L240">                    } catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                            | SecurityException e) {
<span class="nc" id="L242">                        Assertions.fail(String.format(</span>
                                &quot;An exception was thrown while testing class '%s' with the property (getter/setter) '%s': '%s'&quot;,
<span class="nc" id="L244">                                this.clazz.getName(), prop.getName(), e.toString()));</span>
<span class="fc" id="L245">                    }</span>
                }
            }
        }
<span class="fc" id="L249">    }</span>

    /**
     * Clear test.
     */
    void clearTest() {
<span class="fc" id="L255">        final Method[] methods = this.clazz.getDeclaredMethods();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (final Method method : methods) {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (method.getName().equals(&quot;clear&quot;)) {</span>
<span class="fc" id="L258">                final T newClass = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L259">                final T expectedClass = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
                try {
                    // Perform any Post Construction on object without parameters
<span class="fc" id="L262">                    List&lt;Annotation&gt; annotations = null;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    for (final Method mt : methods) {</span>
<span class="fc" id="L264">                        annotations = Arrays.asList(mt.getAnnotations());</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                        for (final Annotation annotation : annotations) {</span>
                            // XXX On purpose logic change to support both javax and jakarta namespace for annotations
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                            if (&quot;PostConstruct&quot;.equals(annotation.annotationType().getSimpleName())</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">                                    &amp;&amp; mt.getParameterTypes().length == 0) {</span>
                                // Invoke method newClass
<span class="fc" id="L270">                                mt.invoke(newClass);</span>
                                // Invoke method expectedClass
<span class="fc" id="L272">                                mt.invoke(expectedClass);</span>
                            }
<span class="fc" id="L274">                        }</span>
                    }
                    // Invoke clear only on newClass
<span class="fc" id="L277">                    newClass.getClass().getMethod(&quot;clear&quot;).invoke(newClass);</span>
<span class="fc" id="L278">                    Assertions.assertEquals(expectedClass, newClass,</span>
<span class="fc" id="L279">                            String.format(&quot;Clear method does not match new object '%s'&quot;, this.clazz));</span>
<span class="nc" id="L280">                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                        | NoSuchMethodException | SecurityException e) {
<span class="nc" id="L282">                    Assertions.fail(String.format(&quot;An exception was thrown while testing the Clear method '%s' : '%s'&quot;,</span>
<span class="nc" id="L283">                            this.clazz.getName(), e.toString()));</span>
<span class="fc" id="L284">                }</span>
            }
        }
<span class="fc" id="L287">    }</span>

    /**
     * Constructors test.
     */
    void constructorsTest() {
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (final Constructor&lt;?&gt; constructor : this.clazz.getConstructors()) {</span>

            // Skip deprecated constructors
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (constructor.isAnnotationPresent(Deprecated.class)) {</span>
<span class="fc" id="L297">                continue;</span>
            }

<span class="fc" id="L300">            final Class&lt;?&gt;[] types = constructor.getParameterTypes();</span>

<span class="fc" id="L302">            final Object[] values = new Object[constructor.getParameterTypes().length];</span>

            // Load Data
<span class="fc bfc" id="L305" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L306">                values[i] = this.buildValue(types[i], LoadType.STANDARD_DATA);</span>
            }

            try {
<span class="fc" id="L310">                constructor.newInstance(values);</span>
<span class="nc" id="L311">            } catch (final InstantiationException | IllegalAccessException | InvocationTargetException e) {</span>
<span class="nc" id="L312">                Assertions.fail(</span>
<span class="nc" id="L313">                        String.format(&quot;An exception was thrown while testing the constructor(s) '%s' with '%s': '%s'&quot;,</span>
<span class="nc" id="L314">                                constructor.getName(), Arrays.toString(values), e.toString()));</span>
<span class="fc" id="L315">            }</span>

            // TODO 1/12/2019 JWL Add checking of new object properties
        }
<span class="fc" id="L319">    }</span>

    /**
     * Check Serializable test.
     */
    void checkSerializableTest() {
<span class="fc" id="L325">        final T object = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (this.implementsSerializable(object)) {</span>
<span class="fc" id="L327">            final T newObject = this.canSerialize(object);</span>
            // Toggle to throw or not throw error with only one way working
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (this.skipStrictSerializable != SkipStrictSerialize.ON) {</span>
<span class="fc" id="L330">                Assertions.assertEquals(object, newObject);</span>
            } else {
<span class="fc" id="L332">                Assertions.assertNotEquals(object, newObject);</span>
            }
<span class="fc" id="L334">            return;</span>
        }

        // Only throw error when specifically checking on serialization
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (this.checkSerializable == CheckSerialize.ON) {</span>
<span class="nc" id="L339">            Assertions.fail(String.format(&quot;Class is not serializable '%s'&quot;, object.getClass().getName()));</span>
        }
<span class="fc" id="L341">    }</span>

    /**
     * Implements serializable.
     *
     * @param object
     *            the object
     *
     * @return true, if successful
     */
    boolean implementsSerializable(final T object) {
<span class="pc bpc" id="L352" title="1 of 4 branches missed.">        return object instanceof Externalizable || object instanceof Serializable;</span>
    }

    /**
     * Can serialize.
     *
     * @param object
     *            the object
     *
     * @return object read after serialization
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    T canSerialize(final T object) {
<span class="fc" id="L365">        byte[] byteArray = null;</span>

        // Serialize data
<span class="fc" id="L368">        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L369">                ObjectOutputStream oos = new ObjectOutputStream(baos)) {</span>
<span class="fc" id="L370">            oos.writeObject(object);</span>
<span class="fc" id="L371">            byteArray = baos.toByteArray();</span>
<span class="nc" id="L372">        } catch (final IOException e) {</span>
<span class="nc" id="L373">            Assertions.fail(String.format(&quot;An exception was thrown while serializing the class '%s': '%s',&quot;,</span>
<span class="nc" id="L374">                    object.getClass().getName(), e.toString()));</span>
<span class="nc" id="L375">            return null;</span>
<span class="fc" id="L376">        }</span>

        // Deserialize Data
<span class="fc" id="L379">        try (ByteArrayInputStream bais = new ByteArrayInputStream(byteArray);</span>
<span class="fc" id="L380">                ObjectInputStream ois = new ObjectInputStream(bais)) {</span>
<span class="fc" id="L381">            return (T) ois.readObject();</span>
<span class="nc" id="L382">        } catch (final ClassNotFoundException | IOException e) {</span>
<span class="nc" id="L383">            Assertions.fail(String.format(&quot;An exception was thrown while deserializing the class '%s': '%s',&quot;,</span>
<span class="nc" id="L384">                    object.getClass().getName(), e.toString()));</span>
        }
<span class="nc" id="L386">        return null;</span>
    }

    /**
     * Builds the value.
     *
     * @param &lt;R&gt;
     *            the generic type
     * @param returnType
     *            the return type
     * @param loadType
     *            the load type
     *
     * @return the object
     */
    private &lt;R&gt; Object buildValue(final Class&lt;R&gt; returnType, final LoadType loadType) {
<span class="fc" id="L402">        final ValueBuilder valueBuilder = new ValueBuilder();</span>
<span class="fc" id="L403">        valueBuilder.setLoadData(this.loadData);</span>
<span class="fc" id="L404">        return valueBuilder.buildValue(returnType, loadType);</span>
    }

    /**
     * Tests the equals/hashCode/toString methods of the specified class.
     */
    public void equalsHashCodeToStringSymmetricTest() {
        // Run Equals Verifier
<span class="fc" id="L412">        this.processEqualsVerifierSymmetricTest();</span>

        // Create two new instances of the class under test and test equals, hashcode, and toString on them
<span class="fc" id="L415">        final T x = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L416">        final T y = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L417">        this.processClassEqualsHashCodeToStringSymmetricTest(x, y);</span>

        // TODO 1/12/2019 JWL Internalize extension will require canEquals, equals, hashcode, and toString overrides.
        /*
         * try { this.extension = (Class&lt;E&gt;) new ExtensionBuilder&lt;T&gt;().generate(this.clazz); } catch (NotFoundException
         * e) { Assert.fail(e.getMessage()); } catch (CannotCompileException e) { Assert.fail(e.getMessage()); }
         */

        // If there is an extension, create an instance and test equals, hashcode, and toString on it against the empty
        // class instance
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (this.extension != null) {</span>
<span class="fc" id="L428">            final E ext = new ClassInstance&lt;E&gt;().newInstance(this.extension);</span>
<span class="fc" id="L429">            this.processExtensionEqualsHashCodeToStringSymmetricTest(y, ext);</span>
        }
<span class="fc" id="L431">    }</span>

    /**
     * Process equals verifier symmetric test.
     */
    private void processEqualsVerifierSymmetricTest() {
        // Run Equals Verifier
        try {
<span class="fc" id="L439">            EqualsVerifier.simple().forClass(this.clazz).suppress(Warning.BIGDECIMAL_EQUALITY).verify();</span>
<span class="nc" id="L440">        } catch (AssertionError e) {</span>
<span class="nc" id="L441">            JavaBeanTesterWorker.logger.warn(&quot;EqualsVerifier attempt failed: {}&quot;, e.getMessage());</span>
<span class="fc" id="L442">        }</span>
<span class="fc" id="L443">    }</span>

    /**
     * Process class equals hash code to string symmetric test.
     *
     * @param x
     *            the x
     * @param y
     *            the y
     */
    private void processClassEqualsHashCodeToStringSymmetricTest(final T x, final T y) {
        // Verify that the objects were created successfully before testing equals, hashcode, and toString
<span class="fc" id="L455">        Assertions.assertNotNull(x,</span>
<span class="fc" id="L456">                String.format(&quot;Create new instance of class '%s' resulted in null&quot;, this.clazz.getName()));</span>
<span class="fc" id="L457">        Assertions.assertNotNull(y,</span>
<span class="fc" id="L458">                String.format(&quot;Create new instance of class '%s' resulted in null&quot;, this.clazz.getName()));</span>

        // Test Equals, HashCode, and ToString on Empty Objects
<span class="fc" id="L461">        Assertions.assertEquals(x, y,</span>
<span class="fc" id="L462">                String.format(&quot;.equals() should be consistent for two empty objects of type %s&quot;, this.clazz.getName()));</span>
<span class="fc" id="L463">        Assertions.assertEquals(x.hashCode(), y.hashCode(), String</span>
<span class="fc" id="L464">                .format(&quot;.hashCode() should be consistent for two empty objects of type %s&quot;, this.clazz.getName()));</span>
<span class="fc" id="L465">        Assertions.assertEquals(x.toString(), y.toString(), String</span>
<span class="fc" id="L466">                .format(&quot;.toString() should be consistent for two empty objects of type %s&quot;, this.clazz.getName()));</span>

        // Test One Sided Tests on Empty Objects
<span class="fc" id="L469">        Assertions.assertNotEquals(x, null,</span>
<span class="fc" id="L470">                String.format(&quot;An empty object of type %s should not be equal to null&quot;, this.clazz.getName()));</span>
<span class="fc" id="L471">        Assertions.assertEquals(x, x,</span>
<span class="fc" id="L472">                String.format(&quot;An empty object of type %s should be equal to itself&quot;, this.clazz.getName()));</span>

        // If the class has setters, the previous tests would have been against empty classes
        // If so, load the classes and re-test
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (this.classHasSetters(this.clazz)) {</span>
            // Populate Side X
<span class="fc" id="L478">            JavaBeanTesterWorker.load(this.clazz, x, this.loadData);</span>

            // ReTest Equals (flip)
<span class="fc" id="L481">            Assertions.assertNotEquals(y, x,</span>
<span class="fc" id="L482">                    String.format(&quot;.equals() should not be consistent for one empty and one loaded object of type %s&quot;,</span>
<span class="fc" id="L483">                            this.clazz.getName()));</span>

            // Populate Side Y
<span class="fc" id="L486">            JavaBeanTesterWorker.load(this.clazz, y, this.loadData);</span>

            // ReTest Equals and HashCode
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (this.loadData == LoadData.ON) {</span>
<span class="fc" id="L490">                Assertions.assertEquals(x, y,</span>
<span class="fc" id="L491">                        String.format(&quot;.equals() should be equal for two instances of type %s with loaded data&quot;,</span>
<span class="fc" id="L492">                                this.clazz.getName()));</span>
<span class="fc" id="L493">                Assertions.assertEquals(x.hashCode(), y.hashCode(),</span>
<span class="fc" id="L494">                        String.format(&quot;.hashCode() should be equal for two instances of type %s with loaded data&quot;,</span>
<span class="fc" id="L495">                                this.clazz.getName()));</span>
            } else {
                // Part of the data loaded may be the same, so we cannot guarantee that equals and hashcode will be
                // different, but we can at least check that they are not both the same
                // Assertions.assertNotEquals(x, y);
                // Assertions.assertNotEquals(x.hashCode(), y.hashCode());
<span class="fc bfc" id="L501" title="All 2 branches covered.">                if (x.hashCode() == y.hashCode()) {</span>
<span class="fc" id="L502">                    Assertions.assertEquals(x, y);</span>
<span class="fc" id="L503">                    Assertions.assertEquals(x.hashCode(), y.hashCode());</span>
                } else {
<span class="fc" id="L505">                    Assertions.assertNotEquals(x, y);</span>
<span class="fc" id="L506">                    Assertions.assertNotEquals(x.hashCode(), y.hashCode());</span>
                }
            }
        }

        // Create Immutable Instance
        try {
<span class="fc" id="L513">            final T e = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L514">            ByteBuddyBeanCopier.copy(x, e, (value, targetType) -&gt; {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                if (targetType == boolean.class) {</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">                    return value == null ? Boolean.FALSE : value;</span>
                }
<span class="fc" id="L518">                return value;</span>
            });
<span class="fc" id="L520">            Assertions.assertEquals(e, x);</span>
<span class="nc" id="L521">        } catch (final Exception e) {</span>
<span class="nc" id="L522">            JavaBeanTesterWorker.logger.trace(&quot;Do nothing class is not mutable&quot;, e);</span>
<span class="fc" id="L523">        }</span>
<span class="fc" id="L524">    }</span>

    /**
     * Process extension equals hash code to string symmetric test.
     *
     * @param y
     *            the y
     * @param ext
     *            the ext
     */
    private void processExtensionEqualsHashCodeToStringSymmetricTest(final T y, final E ext) {
        // Verify that the objects were created successfully before testing equals, hashcode, and toString
<span class="fc" id="L536">        Assertions.assertNotNull(ext,</span>
<span class="fc" id="L537">                String.format(&quot;Create new instance of extension %s resulted in null&quot;, this.extension.getName()));</span>

        // Test Extension Equals, HashCode, and ToString on Empty Objects
<span class="fc" id="L540">        Assertions.assertNotEquals(ext, y,</span>
<span class="fc" id="L541">                String.format(&quot;.equals() should not be equal for extension of type %s and empty object of type %s&quot;,</span>
<span class="fc" id="L542">                        this.extension.getName(), this.clazz.getName()));</span>
<span class="fc" id="L543">        Assertions.assertNotEquals(ext.hashCode(), y.hashCode(),</span>
<span class="fc" id="L544">                String.format(&quot;.hashCode() should not be equal for extension of type %s and empty object of type %s&quot;,</span>
<span class="fc" id="L545">                        this.extension.getName(), this.clazz.getName()));</span>
<span class="fc" id="L546">        Assertions.assertNotEquals(ext.toString(), y.toString(),</span>
<span class="fc" id="L547">                String.format(&quot;.toString() should not be equal for extension of type %s and empty object of type %s&quot;,</span>
<span class="fc" id="L548">                        this.extension.getName(), this.clazz.getName()));</span>

        // Test Extension One Sided Tests on Empty Objects
<span class="fc" id="L551">        Assertions.assertNotEquals(ext, null,</span>
<span class="fc" id="L552">                String.format(&quot;An empty extension of type %s should not be equal to null&quot;, this.clazz.getName()));</span>
<span class="fc" id="L553">        Assertions.assertEquals(ext, ext,</span>
<span class="fc" id="L554">                String.format(&quot;An empty extension of type %s should be equal to itself&quot;, this.extension.getName()));</span>

        // If the class has setters, the previous tests would have been against empty classes
        // If so, load the classes and re-test
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (this.classHasSetters(this.clazz)) {</span>
            // Populate Extension Side Ext
<span class="fc" id="L560">            JavaBeanTesterWorker.load(this.extension, ext, this.loadData);</span>

            // ReTest Extension Equals (flip)
<span class="fc" id="L563">            Assertions.assertNotEquals(y, ext,</span>
<span class="fc" id="L564">                    String.format(&quot;.equals() should not be equal for extension of type %s and empty object of type %s&quot;,</span>
<span class="fc" id="L565">                            this.extension.getName(), this.clazz.getName()));</span>

            // Populate Side Y
<span class="fc" id="L568">            JavaBeanTesterWorker.load(this.clazz, y, this.loadData);</span>

            // ReTest Extension Equals, HashCode, and ToString
<span class="fc" id="L571">            Assertions.assertNotEquals(ext, y,</span>
<span class="fc" id="L572">                    String.format(&quot;.equals() should not be equal for extension of type %s and empty object of type %s&quot;,</span>
<span class="fc" id="L573">                            this.extension.getName(), this.clazz.getName()));</span>
<span class="fc" id="L574">            Assertions.assertNotEquals(ext.hashCode(), y.hashCode(),</span>
<span class="fc" id="L575">                    String.format(</span>
                            &quot;.hashCode() should not be equal for extension of type %s and empty object of type %s&quot;,
<span class="fc" id="L577">                            this.extension.getName(), this.clazz.getName()));</span>
<span class="fc" id="L578">            Assertions.assertNotEquals(ext.toString(), y.toString(),</span>
<span class="fc" id="L579">                    String.format(</span>
                            &quot;.toString() should not be equal for extension of type %s and empty object of type %s&quot;,
<span class="fc" id="L581">                            this.extension.getName(), this.clazz.getName()));</span>
        }

        // If class is final, use Object.class for comparison needs
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (Modifier.isFinal(clazz.getModifiers())) {</span>
<span class="fc" id="L586">            JavaBeanTesterWorker.logger.trace(&quot;Final object does not go through final equals check&quot;);</span>
<span class="fc" id="L587">            return;</span>
        }

        // Create Extension Immutable Instance
        try {
<span class="fc" id="L592">            final E e = new ClassInstance&lt;E&gt;().newInstance(this.extension);</span>
<span class="fc" id="L593">            ByteBuddyBeanCopier.copy(ext, e, (value, targetType) -&gt; {</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (targetType == boolean.class) {</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                    return value == null ? Boolean.FALSE : value;</span>
                }
<span class="fc" id="L597">                return value;</span>
            });
<span class="fc" id="L599">            Assertions.assertEquals(e, ext);</span>
<span class="nc" id="L600">        } catch (final Exception e) {</span>
<span class="nc" id="L601">            JavaBeanTesterWorker.logger.trace(&quot;Do nothing class is not mutable&quot;, e);</span>
<span class="fc" id="L602">        }</span>
<span class="fc" id="L603">    }</span>

    /**
     * Equals Tests will traverse one object changing values until all have been tested against another object. This is
     * done to effectively test all paths through equals.
     *
     * @param instance
     *            the class instance under test.
     * @param expected
     *            the instance expected for tests.
     */
    void equalsTests(final T instance, final T expected) {

        // Perform hashCode test dependent on data coming in
        // Assert.assertEquals(expected.hashCode(), instance.hashCode());
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (expected.hashCode() == instance.hashCode()) {</span>
<span class="fc" id="L619">            Assertions.assertEquals(expected.hashCode(), instance.hashCode());</span>
        } else {
<span class="fc" id="L621">            Assertions.assertNotEquals(expected.hashCode(), instance.hashCode());</span>
        }

<span class="fc" id="L624">        final ValueBuilder valueBuilder = new ValueBuilder();</span>
<span class="fc" id="L625">        valueBuilder.setLoadData(this.loadData);</span>

<span class="fc" id="L627">        final PropertyDescriptor[] props = this.getProps(instance.getClass());</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">        for (final PropertyDescriptor prop : props) {</span>
<span class="fc" id="L629">            Method getter = prop.getReadMethod();</span>
<span class="fc" id="L630">            final Method setter = prop.getWriteMethod();</span>

            // Java Metro Bug Patch (Boolean Wrapper usage of 'is' possible
<span class="pc bpc" id="L633" title="1 of 4 branches missed.">            if (getter == null &amp;&amp; setter != null) {</span>
<span class="fc" id="L634">                final String isBooleanWrapper = &quot;is&quot; + setter.getName().substring(3);</span>
                try {
<span class="fc" id="L636">                    getter = this.clazz.getMethod(isBooleanWrapper);</span>
<span class="nc" id="L637">                } catch (NoSuchMethodException | SecurityException e) {</span>
                    // Do nothing
<span class="fc" id="L639">                }</span>
            }

<span class="pc bpc" id="L642" title="1 of 4 branches missed.">            if (getter != null &amp;&amp; setter != null) {</span>
                // We have both a get and set method for this property
<span class="fc" id="L644">                final Class&lt;?&gt; returnType = getter.getReturnType();</span>
<span class="fc" id="L645">                final Class&lt;?&gt;[] params = setter.getParameterTypes();</span>

<span class="pc bpc" id="L647" title="2 of 4 branches missed.">                if (params.length == 1 &amp;&amp; params[0] == returnType) {</span>
                    // The set method has 1 argument, which is of the same type as the return type of the get method, so
                    // we can test this property
                    try {
                        // Save original value
<span class="fc" id="L652">                        final Object original = getter.invoke(instance);</span>

                        // Build a value of the correct type to be passed to the set method using alternate test
<span class="fc" id="L655">                        Object value = valueBuilder.buildValue(returnType, LoadType.ALTERNATE_DATA);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L658">                        setter.invoke(instance, value);</span>

                        // Check equals depending on data
<span class="fc bfc" id="L661" title="All 2 branches covered.">                        if (instance.equals(expected)) {</span>
<span class="fc" id="L662">                            Assertions.assertEquals(expected, instance);</span>
                        } else {
<span class="fc" id="L664">                            Assertions.assertNotEquals(expected, instance);</span>
                        }

                        // Build a value of the correct type to be passed to the set method using null test
<span class="fc" id="L668">                        value = valueBuilder.buildValue(returnType, LoadType.NULL_DATA);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L671">                        setter.invoke(instance, value);</span>

                        // Check equals depending on data
<span class="fc bfc" id="L674" title="All 2 branches covered.">                        if (instance.equals(expected)) {</span>
<span class="fc" id="L675">                            Assertions.assertEquals(expected, instance);</span>
                        } else {
<span class="fc" id="L677">                            Assertions.assertNotEquals(expected, instance);</span>
                        }

                        // Reset to original value
<span class="fc" id="L681">                        setter.invoke(instance, original);</span>

<span class="nc" id="L683">                    } catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                            | SecurityException e) {
<span class="nc" id="L685">                        Assertions.fail(</span>
<span class="nc" id="L686">                                String.format(&quot;An exception was thrown while testing the property (equals) '%s': '%s'&quot;,</span>
<span class="nc" id="L687">                                        prop.getName(), e.toString()));</span>
<span class="fc" id="L688">                    }</span>
                }
            }
        }
<span class="fc" id="L692">    }</span>

    /**
     * Class has setters.
     *
     * @param clazz
     *            the clazz
     *
     * @return true, if successful
     */
    private boolean classHasSetters(final Class&lt;T&gt; clazz) {
<span class="fc" id="L703">        return Arrays.stream(this.getProps(clazz))</span>
<span class="fc bfc" id="L704" title="All 2 branches covered.">                .anyMatch(propertyDescriptor -&gt; propertyDescriptor.getWriteMethod() != null);</span>
    }

    /**
     * Gets the props.
     *
     * @param clazz
     *            the clazz
     *
     * @return the props
     */
    private PropertyDescriptor[] getProps(final Class&lt;?&gt; clazz) {
        try {
<span class="fc" id="L717">            final List&lt;PropertyDescriptor&gt; usedProps = new ArrayList&lt;&gt;(</span>
<span class="fc" id="L718">                    Introspector.getBeanInfo(clazz).getPropertyDescriptors().length);</span>
<span class="fc" id="L719">            final List&lt;PropertyDescriptor&gt; props = Arrays</span>
<span class="fc" id="L720">                    .asList(Introspector.getBeanInfo(clazz).getPropertyDescriptors());</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">            for (final PropertyDescriptor prop : props) {</span>
                // Check the list of properties that we don't want to test
<span class="fc bfc" id="L723" title="All 2 branches covered.">                if (this.skipThese.contains(prop.getName())) {</span>
<span class="fc" id="L724">                    continue;</span>
                }
<span class="fc" id="L726">                usedProps.add(prop);</span>
<span class="fc" id="L727">            }</span>
<span class="fc" id="L728">            return usedProps.toArray(new PropertyDescriptor[0]);</span>
<span class="nc" id="L729">        } catch (final IntrospectionException e) {</span>
<span class="nc" id="L730">            Assertions.fail(String.format(&quot;An exception was thrown while testing class '%s': '%s'&quot;,</span>
<span class="nc" id="L731">                    this.clazz.getName(), e.toString()));</span>
<span class="nc" id="L732">            return new PropertyDescriptor[0];</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>